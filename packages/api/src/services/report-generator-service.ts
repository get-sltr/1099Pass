/**
 * Report Generator Service
 * Generates lender-ready income verification reports in JSON and PDF formats
 * Handles report sharing with secure tokens
 */

import { v4 as uuidv4 } from 'uuid';
import PDFDocument from 'pdfkit';
import { S3Client, PutObjectCommand, GetObjectCommand } from '@aws-sdk/client-s3';
import { getSignedUrl } from '@aws-sdk/s3-request-presigner';
import type { NormalizedIncomeProfile, IncomeSource } from './income-normalization-service';
import type { LoanReadinessScore, LetterGrade } from './loan-score-service';

// Types
export interface ReportMetadata {
  reportId: string;
  borrowerId: string;
  generatedAt: Date;
  expiresAt: Date;
  version: string;
  status: 'DRAFT' | 'FINAL' | 'EXPIRED' | 'REVOKED';
}

export interface BorrowerSummary {
  displayName: string;
  location: string; // City, State only
  accountAgeMonths: number;
  verificationStatus: 'VERIFIED' | 'PARTIALLY_VERIFIED' | 'UNVERIFIED';
  memberSince: Date;
}

export interface IncomeOverview {
  projectedAnnualIncome: number; // Cents
  confidenceIntervalLow: number;
  confidenceIntervalHigh: number;
  activeSourceCount: number;
  averageMonthlyIncome: number;
  trajectory: string;
  trajectoryDescription: string;
}

export interface IncomeSourceSummary {
  name: string;
  type: string;
  monthlyAverage: number; // Cents
  annualTotal: number;
  monthsActive: number;
  verificationStatus: string;
  contributionPercentage: number;
}

export interface MonthlyIncomeData {
  month: string;
  total: number; // Cents
  bySource: Record<string, number>;
}

export interface DocumentVerification {
  documentType: string;
  verifiedAt: Date | null;
  status: 'VERIFIED' | 'PENDING' | 'NOT_PROVIDED';
}

export interface LenderReport {
  // Header
  metadata: ReportMetadata;

  // Borrower Summary
  borrower: BorrowerSummary;

  // Income Overview
  incomeOverview: IncomeOverview;

  // Income Sources Table
  incomeSources: IncomeSourceSummary[];

  // 24-Month History
  monthlyHistory: MonthlyIncomeData[];

  // Stability Metrics
  stabilityMetrics: {
    coefficientOfVariation: number;
    incomeDiversityScore: number;
    seasonalityIndex: number;
    yearOverYearGrowth: number;
    maintenanceProbability: number;
  };

  // Loan Readiness Score
  loanReadinessScore: {
    score: number;
    letterGrade: LetterGrade;
    componentBreakdown: Array<{
      name: string;
      score: number;
      weight: number;
    }>;
  };

  // DTI Estimate
  debtToIncome: {
    estimatedDTI: number;
    monthlyObligations: number;
    caveat: string;
  };

  // Document Verification
  documentVerification: DocumentVerification[];

  // Legal Disclaimer
  disclaimer: string;
}

export interface ShareToken {
  token: string;
  reportId: string;
  borrowerId: string;
  createdAt: Date;
  expiresAt: Date;
  isRevoked: boolean;
  accessCount: number;
  lastAccessedAt: Date | null;
  lastAccessedIp: string | null;
}

export interface ShareAccess {
  token: string;
  accessedAt: Date;
  ipAddress: string;
  userAgent: string;
}

// Constants
const REPORT_VERSION = '1.0.0';
const REPORT_EXPIRY_DAYS = 90;
const SHARE_TOKEN_EXPIRY_DAYS = 30;

const LEGAL_DISCLAIMER = `1099Pass is a data intelligence platform. We are not a lender, loan broker, or financial advisor. 1099Pass does not originate, underwrite, fund, or guarantee any loans. Income reports generated by 1099Pass are informational tools designed to help borrowers present their financial data to lenders. Income reports are not consumer reports under the Fair Credit Reporting Act (FCRA). They are informational tools provided for the borrower's convenience. All lending decisions are made solely by the lender. 1099Pass is not a party to any loan transaction.`;

/**
 * Report Generator Service
 */
export class ReportGeneratorService {
  private s3Client: S3Client;
  private reportsBucket: string;

  constructor(reportsBucket: string, region: string = 'us-east-1') {
    this.s3Client = new S3Client({ region });
    this.reportsBucket = reportsBucket;
  }

  /**
   * Generate a complete lender report
   */
  generateReport(
    borrowerId: string,
    borrowerName: string,
    borrowerCity: string,
    borrowerState: string,
    memberSince: Date,
    incomeProfile: NormalizedIncomeProfile,
    loanScore: LoanReadinessScore,
    documentStatus: DocumentVerification[]
  ): LenderReport {
    const reportId = uuidv4();
    const now = new Date();
    const expiresAt = new Date(now);
    expiresAt.setDate(expiresAt.getDate() + REPORT_EXPIRY_DAYS);

    // Build income source summaries
    const totalIncome = incomeProfile.incomeSources.reduce(
      (sum, s) => sum + s.totalIncomeCents,
      0
    );
    const incomeSources: IncomeSourceSummary[] = incomeProfile.incomeSources.map((source) => ({
      name: source.name,
      type: this.formatIncomeType(source.platformType),
      monthlyAverage: source.monthlyAverageCents,
      annualTotal: source.totalIncomeCents,
      monthsActive: source.monthsActive,
      verificationStatus: source.verificationStatus,
      contributionPercentage:
        totalIncome > 0
          ? Math.round((source.totalIncomeCents / totalIncome) * 1000) / 10
          : 0,
    }));

    // Build monthly history
    const monthlyHistory: MonthlyIncomeData[] = incomeProfile.monthlyHistory.map((m) => ({
      month: m.month,
      total: m.totalCents,
      bySource: m.bySource,
    }));

    // Determine verification status
    const verificationStatus = this.determineVerificationStatus(
      documentStatus,
      incomeProfile.incomeSources
    );

    return {
      metadata: {
        reportId,
        borrowerId,
        generatedAt: now,
        expiresAt,
        version: REPORT_VERSION,
        status: 'FINAL',
      },

      borrower: {
        displayName: this.maskName(borrowerName),
        location: `${borrowerCity}, ${borrowerState}`,
        accountAgeMonths: incomeProfile.monthsAnalyzed,
        verificationStatus,
        memberSince,
      },

      incomeOverview: {
        projectedAnnualIncome: incomeProfile.annualizedProjection.finalProjection,
        confidenceIntervalLow: incomeProfile.annualizedProjection.confidenceIntervalLow,
        confidenceIntervalHigh: incomeProfile.annualizedProjection.confidenceIntervalHigh,
        activeSourceCount: incomeProfile.activeIncomeSourceCount,
        averageMonthlyIncome: incomeProfile.averageMonthlyIncome,
        trajectory: incomeProfile.trajectory,
        trajectoryDescription: this.getTrajectoryDescription(incomeProfile.trajectory),
      },

      incomeSources,
      monthlyHistory,

      stabilityMetrics: {
        coefficientOfVariation: incomeProfile.stabilityMetrics.coefficientOfVariation,
        incomeDiversityScore: incomeProfile.stabilityMetrics.incomeDiversityScore,
        seasonalityIndex: incomeProfile.stabilityMetrics.seasonalityIndex,
        yearOverYearGrowth: incomeProfile.stabilityMetrics.yearOverYearGrowthRate,
        maintenanceProbability: incomeProfile.stabilityMetrics.maintenanceProbability,
      },

      loanReadinessScore: {
        score: loanScore.overallScore,
        letterGrade: loanScore.letterGrade,
        componentBreakdown: [
          {
            name: 'Income Stability',
            score: loanScore.breakdown.incomeStability.rawScore,
            weight: loanScore.breakdown.incomeStability.weight,
          },
          {
            name: 'Income Trend',
            score: loanScore.breakdown.incomeTrend.rawScore,
            weight: loanScore.breakdown.incomeTrend.weight,
          },
          {
            name: 'Income Diversity',
            score: loanScore.breakdown.incomeDiversity.rawScore,
            weight: loanScore.breakdown.incomeDiversity.weight,
          },
          {
            name: 'Documentation',
            score: loanScore.breakdown.documentationCompleteness.rawScore,
            weight: loanScore.breakdown.documentationCompleteness.weight,
          },
          {
            name: 'Income Level',
            score: loanScore.breakdown.incomeLevel.rawScore,
            weight: loanScore.breakdown.incomeLevel.weight,
          },
          {
            name: 'Account Age',
            score: loanScore.breakdown.accountAge.rawScore,
            weight: loanScore.breakdown.accountAge.weight,
          },
        ],
      },

      debtToIncome: {
        estimatedDTI: incomeProfile.debtAnalysis.estimatedDTI,
        monthlyObligations: incomeProfile.debtAnalysis.totalMonthlyObligations,
        caveat: incomeProfile.debtAnalysis.caveat,
      },

      documentVerification: documentStatus,

      disclaimer: LEGAL_DISCLAIMER,
    };
  }

  /**
   * Generate PDF version of the report
   */
  async generatePDF(report: LenderReport): Promise<Buffer> {
    return new Promise((resolve, reject) => {
      const chunks: Buffer[] = [];
      const doc = new PDFDocument({
        size: 'LETTER',
        margins: { top: 50, bottom: 50, left: 50, right: 50 },
        info: {
          Title: `1099Pass Income Verification Report - ${report.metadata.reportId}`,
          Author: '1099Pass',
          Subject: 'Income Verification Report',
          CreationDate: report.metadata.generatedAt,
        },
      });

      doc.on('data', (chunk: Buffer) => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);

      // Header
      this.renderPDFHeader(doc, report);

      // Borrower Summary
      this.renderBorrowerSummary(doc, report);

      // Income Overview
      this.renderIncomeOverview(doc, report);

      // Income Sources Table
      this.renderIncomeSources(doc, report);

      // New page for detailed metrics
      doc.addPage();

      // Stability Metrics
      this.renderStabilityMetrics(doc, report);

      // Loan Readiness Score
      this.renderLoanScore(doc, report);

      // DTI Section
      this.renderDTI(doc, report);

      // Document Verification
      this.renderDocumentVerification(doc, report);

      // Disclaimer (footer on last page)
      this.renderDisclaimer(doc, report);

      doc.end();
    });
  }

  /**
   * Save report to S3
   */
  async saveReport(report: LenderReport, pdf?: Buffer): Promise<void> {
    // Save JSON report
    await this.s3Client.send(
      new PutObjectCommand({
        Bucket: this.reportsBucket,
        Key: `reports/${report.metadata.borrowerId}/${report.metadata.reportId}.json`,
        Body: JSON.stringify(report, null, 2),
        ContentType: 'application/json',
        ServerSideEncryption: 'aws:kms',
      })
    );

    // Save PDF if provided
    if (pdf) {
      await this.s3Client.send(
        new PutObjectCommand({
          Bucket: this.reportsBucket,
          Key: `reports/${report.metadata.borrowerId}/${report.metadata.reportId}.pdf`,
          Body: pdf,
          ContentType: 'application/pdf',
          ServerSideEncryption: 'aws:kms',
        })
      );
    }
  }

  /**
   * Get a presigned URL for downloading the PDF
   */
  async getPDFDownloadUrl(borrowerId: string, reportId: string): Promise<string> {
    const command = new GetObjectCommand({
      Bucket: this.reportsBucket,
      Key: `reports/${borrowerId}/${reportId}.pdf`,
    });

    return getSignedUrl(this.s3Client, command, { expiresIn: 3600 });
  }

  /**
   * Generate a share token for a report
   */
  generateShareToken(reportId: string, borrowerId: string): ShareToken {
    const now = new Date();
    const expiresAt = new Date(now);
    expiresAt.setDate(expiresAt.getDate() + SHARE_TOKEN_EXPIRY_DAYS);

    return {
      token: uuidv4(),
      reportId,
      borrowerId,
      createdAt: now,
      expiresAt,
      isRevoked: false,
      accessCount: 0,
      lastAccessedAt: null,
      lastAccessedIp: null,
    };
  }

  /**
   * Validate and record share access
   */
  validateShareAccess(token: ShareToken, _ipAddress: string): boolean {
    if (token.isRevoked) {
      return false;
    }

    if (new Date() > token.expiresAt) {
      return false;
    }

    return true;
  }

  /**
   * Record share access for audit trail
   */
  recordShareAccess(
    token: ShareToken,
    ipAddress: string,
    userAgent: string
  ): ShareAccess {
    return {
      token: token.token,
      accessedAt: new Date(),
      ipAddress,
      userAgent,
    };
  }

  // PDF Rendering Methods

  private renderPDFHeader(doc: PDFKit.PDFDocument, report: LenderReport): void {
    // Logo area (placeholder - would be actual logo)
    doc
      .fontSize(24)
      .font('Helvetica-Bold')
      .fillColor('#1E3A5F')
      .text('1099Pass', 50, 50);

    doc
      .fontSize(10)
      .font('Helvetica')
      .fillColor('#666666')
      .text('Income Verification Report', 50, 80);

    // Report ID and dates on the right
    doc
      .fontSize(9)
      .fillColor('#999999')
      .text(`Report ID: ${report.metadata.reportId.substring(0, 8)}...`, 400, 50, {
        align: 'right',
      })
      .text(`Generated: ${this.formatDate(report.metadata.generatedAt)}`, 400, 65, {
        align: 'right',
      })
      .text(`Expires: ${this.formatDate(report.metadata.expiresAt)}`, 400, 80, {
        align: 'right',
      });

    // Verification badge
    doc
      .roundedRect(450, 100, 100, 25, 5)
      .fill('#10B981');

    doc
      .fontSize(10)
      .fillColor('#FFFFFF')
      .text('VERIFIED', 465, 107);

    doc.moveDown(3);
  }

  private renderBorrowerSummary(doc: PDFKit.PDFDocument, report: LenderReport): void {
    const y = 140;

    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .fillColor('#1E3A5F')
      .text('Borrower Summary', 50, y);

    doc
      .fontSize(11)
      .font('Helvetica')
      .fillColor('#333333')
      .text(`Name: ${report.borrower.displayName}`, 50, y + 25)
      .text(`Location: ${report.borrower.location}`, 50, y + 42)
      .text(`Account Age: ${report.borrower.accountAgeMonths} months`, 50, y + 59)
      .text(`Status: ${report.borrower.verificationStatus}`, 50, y + 76);

    doc.moveDown(2);
  }

  private renderIncomeOverview(doc: PDFKit.PDFDocument, report: LenderReport): void {
    const y = 250;

    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .fillColor('#1E3A5F')
      .text('Income Overview', 50, y);

    const annual = this.formatCurrency(report.incomeOverview.projectedAnnualIncome);
    const monthly = this.formatCurrency(report.incomeOverview.averageMonthlyIncome);
    const low = this.formatCurrency(report.incomeOverview.confidenceIntervalLow);
    const high = this.formatCurrency(report.incomeOverview.confidenceIntervalHigh);

    doc
      .fontSize(24)
      .font('Helvetica-Bold')
      .fillColor('#10B981')
      .text(annual, 50, y + 25);

    doc
      .fontSize(10)
      .font('Helvetica')
      .fillColor('#666666')
      .text('Projected Annual Income', 50, y + 55)
      .text(`Confidence Range: ${low} - ${high}`, 50, y + 70);

    // Right column
    doc
      .fontSize(11)
      .fillColor('#333333')
      .text(`Monthly Average: ${monthly}`, 300, y + 25)
      .text(`Active Sources: ${report.incomeOverview.activeSourceCount}`, 300, y + 42)
      .text(`Trajectory: ${report.incomeOverview.trajectory}`, 300, y + 59)
      .text(report.incomeOverview.trajectoryDescription, 300, y + 76, { width: 220 });

    doc.moveDown(3);
  }

  private renderIncomeSources(doc: PDFKit.PDFDocument, report: LenderReport): void {
    const y = 380;

    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .fillColor('#1E3A5F')
      .text('Income Sources', 50, y);

    // Table header
    const headerY = y + 25;
    doc
      .fontSize(9)
      .font('Helvetica-Bold')
      .fillColor('#666666')
      .text('Source', 50, headerY)
      .text('Type', 150, headerY)
      .text('Monthly Avg', 250, headerY)
      .text('Annual', 350, headerY)
      .text('Months', 430, headerY)
      .text('%', 500, headerY);

    // Draw header line
    doc
      .moveTo(50, headerY + 15)
      .lineTo(550, headerY + 15)
      .stroke('#E5E7EB');

    // Table rows
    let rowY = headerY + 25;
    for (const source of report.incomeSources.slice(0, 6)) {
      doc
        .fontSize(10)
        .font('Helvetica')
        .fillColor('#333333')
        .text(source.name.substring(0, 15), 50, rowY)
        .text(source.type, 150, rowY)
        .text(this.formatCurrency(source.monthlyAverage), 250, rowY)
        .text(this.formatCurrency(source.annualTotal), 350, rowY)
        .text(source.monthsActive.toString(), 430, rowY)
        .text(`${source.contributionPercentage}%`, 500, rowY);

      rowY += 18;
    }

    if (report.incomeSources.length > 6) {
      doc
        .fontSize(9)
        .fillColor('#999999')
        .text(`+ ${report.incomeSources.length - 6} more sources`, 50, rowY);
    }
  }

  private renderStabilityMetrics(doc: PDFKit.PDFDocument, report: LenderReport): void {
    const y = 50;

    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .fillColor('#1E3A5F')
      .text('Stability Metrics', 50, y);

    const metrics = report.stabilityMetrics;
    const startY = y + 30;

    // Render each metric as a horizontal bar or value
    const metricItems = [
      {
        label: 'Income Diversity',
        value: `${metrics.incomeDiversityScore}/100`,
        description: 'Higher is better',
      },
      {
        label: 'Coefficient of Variation',
        value: metrics.coefficientOfVariation.toFixed(2),
        description: 'Lower is more stable',
      },
      {
        label: 'Year-over-Year Growth',
        value: `${metrics.yearOverYearGrowth >= 0 ? '+' : ''}${metrics.yearOverYearGrowth.toFixed(1)}%`,
        description: metrics.yearOverYearGrowth >= 0 ? 'Growing' : 'Declining',
      },
      {
        label: 'Seasonality Index',
        value: metrics.seasonalityIndex.toFixed(2),
        description: 'Lower means less seasonal',
      },
      {
        label: 'Maintenance Probability',
        value: `${(metrics.maintenanceProbability * 100).toFixed(0)}%`,
        description: 'Likelihood of maintaining income',
      },
    ];

    metricItems.forEach((item, index) => {
      const itemY = startY + index * 35;
      doc
        .fontSize(10)
        .font('Helvetica-Bold')
        .fillColor('#333333')
        .text(item.label, 50, itemY);

      doc
        .fontSize(12)
        .font('Helvetica-Bold')
        .fillColor('#1E3A5F')
        .text(item.value, 250, itemY);

      doc
        .fontSize(9)
        .font('Helvetica')
        .fillColor('#999999')
        .text(item.description, 350, itemY);
    });

    doc.moveDown(4);
  }

  private renderLoanScore(doc: PDFKit.PDFDocument, report: LenderReport): void {
    const y = 250;

    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .fillColor('#1E3A5F')
      .text('Loan Readiness Score', 50, y);

    // Big score display
    const scoreColor = this.getScoreColor(report.loanReadinessScore.score);
    doc
      .fontSize(48)
      .font('Helvetica-Bold')
      .fillColor(scoreColor)
      .text(report.loanReadinessScore.score.toString(), 50, y + 25);

    doc
      .fontSize(24)
      .text(report.loanReadinessScore.letterGrade, 130, y + 35);

    // Component breakdown
    const breakdownY = y + 25;
    report.loanReadinessScore.componentBreakdown.forEach((component, index) => {
      const compY = breakdownY + index * 18;
      doc
        .fontSize(9)
        .font('Helvetica')
        .fillColor('#666666')
        .text(component.name, 250, compY)
        .text(`${component.score}/100`, 400, compY)
        .text(`(${(component.weight * 100).toFixed(0)}%)`, 460, compY);
    });
  }

  private renderDTI(doc: PDFKit.PDFDocument, report: LenderReport): void {
    const y = 420;

    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .fillColor('#1E3A5F')
      .text('Debt-to-Income Estimate', 50, y);

    doc
      .fontSize(24)
      .font('Helvetica-Bold')
      .fillColor(report.debtToIncome.estimatedDTI < 40 ? '#10B981' : '#F59E0B')
      .text(`${report.debtToIncome.estimatedDTI.toFixed(1)}%`, 50, y + 25);

    doc
      .fontSize(10)
      .font('Helvetica')
      .fillColor('#666666')
      .text(
        `Monthly Obligations: ${this.formatCurrency(report.debtToIncome.monthlyObligations)}`,
        50,
        y + 55
      );

    doc
      .fontSize(8)
      .fillColor('#999999')
      .text(report.debtToIncome.caveat, 50, y + 75, { width: 500 });
  }

  private renderDocumentVerification(doc: PDFKit.PDFDocument, report: LenderReport): void {
    const y = 530;

    doc
      .fontSize(14)
      .font('Helvetica-Bold')
      .fillColor('#1E3A5F')
      .text('Document Verification', 50, y);

    const startY = y + 25;
    report.documentVerification.forEach((docItem, index) => {
      const itemY = startY + index * 18;
      const statusColor =
        docItem.status === 'VERIFIED'
          ? '#10B981'
          : docItem.status === 'PENDING'
          ? '#F59E0B'
          : '#9CA3AF';

      doc
        .fontSize(10)
        .font('Helvetica')
        .fillColor('#333333')
        .text(docItem.documentType, 50, itemY);

      doc.fillColor(statusColor).text(docItem.status, 250, itemY);

      if (docItem.verifiedAt) {
        doc
          .fillColor('#999999')
          .text(this.formatDate(docItem.verifiedAt), 350, itemY);
      }
    });
  }

  private renderDisclaimer(doc: PDFKit.PDFDocument, report: LenderReport): void {
    const pageHeight = doc.page.height;
    const y = pageHeight - 120;

    doc
      .rect(40, y - 10, 530, 100)
      .fill('#F9FAFB');

    doc
      .fontSize(6)
      .font('Helvetica')
      .fillColor('#666666')
      .text('DISCLAIMER', 50, y, { width: 510 })
      .moveDown(0.5)
      .text(report.disclaimer, { width: 510, align: 'justify' });
  }

  // Helper methods

  private formatIncomeType(type: string): string {
    const types: Record<string, string> = {
      GIG_PLATFORM: 'Gig Platform',
      CONTRACTOR_1099: '1099 Contractor',
      SELF_EMPLOYMENT: 'Self-Employment',
      INVESTMENT: 'Investment',
      RENTAL: 'Rental',
      OTHER: 'Other',
    };
    return types[type] || type;
  }

  private getTrajectoryDescription(trajectory: string): string {
    const descriptions: Record<string, string> = {
      GROWING: 'Income shows consistent upward trend',
      STABLE: 'Income remains steady month-to-month',
      DECLINING: 'Income shows downward trend',
      VOLATILE: 'Income varies significantly',
      SEASONAL: 'Income follows seasonal patterns',
    };
    return descriptions[trajectory] || 'Income pattern analyzed';
  }

  private determineVerificationStatus(
    docs: DocumentVerification[],
    sources: IncomeSource[]
  ): 'VERIFIED' | 'PARTIALLY_VERIFIED' | 'UNVERIFIED' {
    const verifiedDocs = docs.filter((d) => d.status === 'VERIFIED').length;
    const verifiedSources = sources.filter((s) => s.verificationStatus === 'VERIFIED').length;

    if (verifiedDocs >= 2 && verifiedSources >= 1) return 'VERIFIED';
    if (verifiedDocs >= 1 || verifiedSources >= 1) return 'PARTIALLY_VERIFIED';
    return 'UNVERIFIED';
  }

  private maskName(name: string): string {
    const parts = name.split(' ');
    if (parts.length >= 2) {
      const firstName = parts[0]!;
      const lastName = parts[parts.length - 1]!;
      return `${firstName} ${lastName.charAt(0)}.`;
    }
    return name;
  }

  private formatCurrency(cents: number): string {
    const dollars = cents / 100;
    return new Intl.NumberFormat('en-US', {
      style: 'currency',
      currency: 'USD',
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(dollars);
  }

  private formatDate(date: Date): string {
    return new Intl.DateTimeFormat('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
    }).format(date);
  }

  private getScoreColor(score: number): string {
    if (score >= 80) return '#10B981';
    if (score >= 60) return '#F59E0B';
    return '#EF4444';
  }
}

// Export factory function
export function createReportGeneratorService(
  reportsBucket: string,
  region?: string
): ReportGeneratorService {
  return new ReportGeneratorService(reportsBucket, region);
}
